;;;; -*- Mode: LISP; Syntax: Ansi-Common-Lisp; Base: 10; Package: CL-POSTGRES; -*-

(in-package :saslprep)

(defun string-mapped-to-nothing (str)
  "Reads a string and removes any character that should be mapped to nothing per RFC 3454 and RFC 4013."
  (let ((s1 (coerce str 'simple-vector))
        (lst nil)
        (skip nil))
    (loop for x across s1 counting x into y do
         (cond ((char-mapped-to-nothing-p x)
                (setf skip t))
               ((characterp x)
                (push x lst))
               (t (return nil))))
    (setf lst (nreverse lst))
    (format nil "~{~A~}" lst)))

(defun string-mapped-to-space (str)
  "Reads a string and converts any character which should be mapped to a space pre RFC 3454 and RFC 4013 to a space."
  (let ((s1 (coerce str 'simple-vector)))
    (loop for x across s1 counting x into y do
         (when (char-mapped-to-space-p x)
           (setf (aref s1 (- y 1)) #\Space)))
    (coerce s1 'string)))

(defun saslprep-normalize (str &optional (form :nfkc))
  "Scans string. If any character should be mapped to nothing, it eliminates that character. If any character is not printable ascii, it returns nil. If every character remaining after eliminations is printable ascii, it returns the printable-ascii string. "
  (when (string-printable-ascii-p str)
    (return-from saslprep-normalize str))
  (setf str (string-mapped-to-nothing str))
  (setf str (string-mapped-to-space str))
  (setf str (normalize str form))
  (let ((bidirectional-check nil))
    (loop for x across str do
         (when (or (non-ascii-control-char-p x)
                   (ascii-control-char-p x)
                   (non-ascii-space-char-p x)
                   (private-use-char-p x)
                   (non-char-code-point-p x)
                   (surrogate-code-points-p x)
                   (inappropriate-for-plain-text-p x)
                   (inappropriate-for-canonical-representation-char-p x)
                   (change-display-property-char-p x)
                   (tagging-char-p x))
           (bad-char-error "prohibited output in string per RFC 4013" :value x))
         (cond ((and (not bidirectional-check)
                     (char-with-bidirectional-property-R-or-AL-p x))
                (setf bidirectional-check "R"))
               ((and (not bidirectional-check)
                     (char-with-bidirectional-property-L-p x))
                (setf bidirectional-check "L"))
               ((and (equal bidirectional-check "L")
                     (char-with-bidirectional-property-R-or-AL-p x))
                (bad-char-error "Conflicting bidirectional characters in string" :value str))
               ((and (equal bidirectional-check "R")
                     (char-with-bidirectional-property-L-p x))
                (bad-char-error "Conflicting bidirectional characters in string" :value str))
               (t nil))))
  str)
